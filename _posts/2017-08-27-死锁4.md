---
layout: post
title: 死锁
---

什么是死锁

一组processes陷入互相等待的情况（Circular Waiting），其中的每一个process，都不能往下执行，使得CPU利用率及吞吐量大幅降低的情况。

在一个已经形成死锁的系统中，能够看到类似于以上的一幅图：Process P1持有了资源R2，等待资源R1；Process P2持有了资源R1，等待资源R2；将持有、等待等关系链接起来，就形成了一个环------死锁中必定存在一个环形图。
将图中的资源节点去掉，仅仅留下Processes节点，P1等待P2，P2等待P1，这种等待关系图，称之为Wait-For-Graph（WFG）。
死锁发生的前提

死锁的发生，有四个大的前提：
互斥性（Mutual Exclusion）
资源在同一时间内，只能允许一个Process使用，不允许多个Processes同时持有资源。例如：Mutex，Spinlock，RWLock（Write Mode），都提供了互斥性。一个Process持有了Mutex之后，其他的Process必须等待，而已经获得Mutex的Process，可以进入Mutex所保护的临界区，做相应的操作。 
持有并等待（Hold & Wait）
构成死锁的前提之二，是每个Process，必须持有了某些资源，然后去等待获取另外的一些资源。例如：持有了一个Mutex，然后去等待获取第二个Mutex。 
非抢占（No Preemption）
等待的Process，不能抢占已经持有此资源的其他Process，除非其他Process自愿放弃他所持有的资源。画外音：我用完了会给你，但是我不给你前，你也不能抢。 
循环等待（Circular Waiting）
在前面的三个基础之上，如果等待的Processes之间，形成了环形等待，则说明出现了死锁。 
死锁处理的方法

死锁处理方法，一般可以分为两类：
死锁预防 vs 死锁避免
针对死锁产生的四个前提条件，事先规定一种加锁规则，使得死锁永远不会产生：死锁预防（Deadlock Prevention）；或者是在编码实现中仔细、小心的分配各类资源，使得死锁不会发生：死锁避免（Deadlock Avoidance）。
现实中，死锁预防是比较常用的技术，而死锁避免实现要求较高，很少被使用。 
死锁检测 & 死锁处理
死锁预防与死锁避免，都能够保证不产生死锁。但是，死锁有时是无法避免的，此时就需要死锁发生之后的策略。如何检测到已发生死锁？在检测到死锁之后，如何解开死锁？对应的技术，分别为：死锁检测 和 死锁处理。
死锁预防

针对互斥性
死锁发生的四个前提之一，是互斥性。针对互斥性，最简单的想法是将互斥的资源转换为不互斥的资源。实践举例：
1.       将全局资源转为局部资源
多线程分配内存，原来需要从一个全局内存中进行分配，现在可改为为每个线程事先分配一个内存池，线程可在自己的内存池中分配内存，杜绝了全局资源竞争； 
多线程访问一个全局计数器，可改成为每一个线程分配一个局部计算器，线程访问自己的局部计数器，无需加锁。 
2.       降低锁粒度，细化互斥资源
在MySQL数据库InnoDB引擎的早期版本中，为了实现简单，一个Kernel_Mutex，保护了系统内的很多资源。而在后期的版本中，通过不断的拆分Kernel_Mutex，资源的管理更为细化，原本互斥的资源，在新的体系下就不再互斥。 
针对持有并等待
死锁发生的四个前提之二，是持有并等待。针对此问题，也有一些处理方法：
1.         永远不同时持有一个以上的资源
只持有一个资源，也就不会出现持有并等待的情况，这是消除死锁的最好办法。持有了一个Mutex，就不应该去加另一个Mutex。在数据库内核编码中，这是最常用的，消除死锁的技术之一。 
2.         同时获取所有资源，否则释放后重试
如果必须要同时持有多个资源（例如多个Mutex），此时无法消除持有，那么可以考虑消除等待条件。一种通用的做法是：以不等待的方式，获取所有的资源，如果任何一个资源获取失败，则释放所有已经获取的资源，重新开始。这种方法，会持有多种资源，但是不会等待，因此也不会产生死锁。
在MySQL Server层面，一条SQL如果访问多张表，那么需要对着多张表加锁，加锁的方式就是这里提到的方法：以不等待的方式对表加锁，如果全部加锁成功，则开始处理SQL，否则，释放所有已经持有的锁，重新开始。 
针对非抢占
死锁发生的前提之三，是非抢占特性。针对此特性，那么只要允许抢占即可。允许抢占的几种方式：
1.         Wound-Wait
在系统中，每一个Process，其开始的时间，可以设置为其年龄。那么，每一个Process根据其年龄，可以排出大小之分。越早开始的Process，年龄越大，称之为Pold；越晚开始的Process，年龄越小，称之为Pnew。
Wound-Wait抢占方式，规定当Pold等待Pnew持有的资源时，Pold可以抢占Pnew的资源，Pnew重启；当Pnew等待Pold持有的资源时，Pnew可以等待Pold。单向等待，因此不会产生死锁。
Google Spanner系统，使用的就是Wound-Wait方式，来预防死锁的。Wound-Wait方式的好处是，Pnew被抢占重启后，就可以等待在Pold上，重启一次即可，无需反复重启。 
2.         Wait-Die
相对于Wound-Wait，另一种抢占方式为Wait-Die。Pold可以等待Pnew，而Pnew如果等待Pold，则Pnew自杀，重试。
相对于Wound-Wait，Wait-Die最大的问题，是Pnew可能会反复重启，效率低下。这也是Google选择Wound-Wait的原因之一。 
针对循环等待
死锁发生的前提之四，是循环等待。只要消除循环等待，即可预防死锁的发生。消除循环等待，有一个使用非常广泛的方法：
1.         为资源设置优先级，并设置持有顺序
为每一个资源设置一个唯一编号，代表这个资源的优先级。当需要持有多个资源时，按照资源优先级的降序（升序）等待获取这些资源，由于所有的Process，都是按照一个顺序获取资源，因此就不会产生死锁。
这是一个使用最为广泛的死锁预防策略。在Oracle数据库中，各类Mutex，RWLock资源，有十几种优先级。在数据库B+树索引的遍历过程中，可以规定B+树的父亲节点的资源优先级大于儿子节点，左边叶子节点的资源优先级大于右边叶子节点，以此来预防索引B+树遍历与SMO，索引正向扫描与反向扫描之间，可能会发生的死锁。
死锁检测

死锁预防的方法，是根据现实情况来选择的。在很多时候，所有的死锁预防策略均不能使用，死锁一定会发生，此时，就需要系统能够主动定位出死锁已经发生，并且处理这已经发生的死锁。死锁检测，也有一些常用的方法：
超时等待方法
最简单的死锁检测方法，就是超时等待法。每次等待，设置一个超时时间，如果在超时时间内没有获得资源，则认为发生死锁，Process主动释放自己已持有的所有资源，退出。
超时等待方法，是最为常用的一种死锁检测的方法。在MySQL数据库中，可以通过 innodb_lock_wait_timeout 参数，设置每个加锁等待的超时时间，超时后，事务自动回滚。但是，超时等待方法也有不足之处，一是检测出死锁的延时较大；二是存在误杀情况，实际上却没有死锁发生；三是很难设置合适的超时时间。 
遍历WFG，主动检测死锁
相对于超时等待方法，死锁检测通常会使用给为主动的方式：遍历WFG，主动检测死锁。WFG，Wait-For-Graph，系统维护一个Processes间的等待关系，然后从任何一个Process出发，遍历等待关系，看等待关系是否构成了环。如果成环，说明存在死锁，否则无死锁。
通过遍历WFG，主动检测死锁，相对于超时等待，检测死锁更为及时。但是，此方法难度也更大，MySQL InnoDB引擎，在多个版本优化之后，死锁主动检测仍旧会有性能上的问题，需要配合超时等待方法，二者同时使用。 
死锁处理

检测到死锁，就要处理死锁。死锁处理，常用的方法有：
杀死检测到死锁的Process
基于超时的死锁检测，如果当前Process发生加锁超时，则被选为牺牲者。选为牺牲者的Process，需要释放持有的所有资源，然后结束。 
杀死死锁环中，权重最低的Process
主动检测死锁的方式，死锁环中的任何一个Process，均可以牺牲。此时，牺牲者的选择，可以根据Process的权重来进行。
例如，在MySQL InnoDB引擎中，Process的权重定义如下：Process越来，权重越高；Process加锁越多，权重越高；Process写日志越多，权重越高。最后，选择死锁环中，权重最低的Process，作为牺牲者。 
牺牲Process的处理
Process被选为死锁牺牲者之后，可以根据系统的实现，选择是在系统内部对Process进行重做；或者是告诉用户死锁发生，由用户选择是否重做（数据库的方案）。 
死锁的其他情况

活锁（Livelock）

相对于死锁，活锁可能稍难理解一些。活锁在现实中的一个例子，如下图所示：

一条路，刚好可以并排走两个人，两人迎面走来，开始都在右侧，发现不行，然后同时换到左侧，仍旧不行，再换… 两个人虽然都在动，但是没有前进，就构成了活锁。
活锁在系统中也会遇到，前面提到的死锁预防的方法之一：同时获取所有资源，否则释放后重试，就有可能会导致活锁。两个Process，P1持有R1资源，P2持有R2资源，然后并发的，P1不等待获取R2资源，P2不等待获取R1资源，两个同时失败，然后同时放锁，然后P1又重新持有R1，P2又重新持有R2，新的循环，又失败… 此外，在Paxos算法中也同样存在活锁的问题。
一般而言，活锁相对于死锁来说，产生的条件更为苛刻，而且任何一个Process调度发生小的变化，都可能会打破活锁。也正是如此，MySQL Server并没有显示处理活锁的问题。 
饥饿（Starvation）

饥饿不属于死锁的特殊情况，而是属于加锁调度策略的问题。此处简单做一个说明：多个Process同时等待一个资源，此时持有资源的Process释放资源，等待的Process竞争资源，如果等待的Process拥有同样的优先级，那么一个老的Process，有可能会长时间竞争不到资源，导致长时间的饥饿情况。解决饥饿问题，有几种较为简单的方式：
FIFO队列
所有等待的Processes，按照等待资源的先后顺序，组织为一个FIFO的队列，资源释放后，FIFO队列中第一个等待者获取资源。 
优先级策略
为每个等待的Processes设置一个优先级，等待的时间越长，优先级越高，优先级越高的Process，有更高的几率获得资源。 
经验总结

可尝试的优化

减少一把全局大锁保护的资源数量，拆分为多个小锁；
锁等待的过程中，定期从等待中苏醒过来，判断有没有被杀掉：处理长时间未能检测到死锁的情况，人工干预，可以打破死锁环；
需要杜绝的情况

持有一个资源去访问外部接口：你不知道这个调用，会多少时间返回；（调用I/O接口）这样的做法，会导致资源长时间无意义的占用；
锁泄漏：锁持有的时间越短越好，跨越多个函数调用的锁，很有可能由于异常处理未覆盖而导致锁泄漏出现；
参考资料

wikipedia. Deadlock
ntnu. Deadlock(死结)
cycu. 死结(Deadlock)
rutgers.Distributed deadlocks. 

![_config.yml]({{ site.baseurl }}/images/config.png)

The easiest way to make your first post is to edit this one. Go into /_posts/ and update the Hello World markdown file. For more instructions head over to the [Jekyll Now repository](https://github.com/barryclark/jekyll-now) on GitHub.